//http://rosettacode.org/wiki/Langton%27s_ant#Dyalect
type Point(var Integer x, var Integer y)

type Ant using {
    let (north, east, west, south) = (0, 1, 2, 3)
    let leftTurns  = [ west, north, south, east ]
    let rightTurns = [ east, south, north, west ]
    let xInc = [0, 1, -1, 0]
    let yInc = [-1, 0, 0, 1]
    var (position, origin, outOfBounds, direction, width, height) = (nil, nil, false, east, nil, nil)
}

static func Ant.Ant(Integer width, Integer height) {
    using private()
    ::position = Point(0, 0)
    ::origin = Point(width / 2, height / 2)
    ::width = width
    ::height = height
}

func Ant.get(field) {
    match field {
        "position" => private()::position,
        "origin" => private()::origin,
        _ => Error.IndexOutOfRange()
    }
}

func Ant.isOutOfBounds() => private()::outOfBounds

func Ant.move() {
    using private()
    let pos = ::position
    pos::x += ::xInc[::direction]
    pos::y += ::yInc[::direction]
    let pt = Point(pos::x + ::origin::x, pos::y + ::origin::y)
    ::outOfBounds = 
        pt::x < 0 ||
        pt::x >= ::width ||
        pt::y < 0 ||
        pt::y >= ::height
    return pos
}

func Ant.changeDirection(Bool left) {
    using private()
    ::direction = left ? ::leftTurns[private()::direction] : ::rightTurns[::direction]
}
 
func Array.step(ant) {
    var ptCur = Point(ant::position::x + ant::origin::x, ant::position::y + ant::origin::y)
    var leftTurn = this[ptCur::x][ptCur::y]
    ant.changeDirection(leftTurn)
    this[ptCur::x][ptCur::y] = !this[ptCur::x][ptCur::y]
    ant.move()
}
 
func run() {
    let (w, h) = (100, 100)
    let blacks = Array.empty(w, () => Array.empty(h, false))
    let ant = Ant(w, h)
 
    while !ant.isOutOfBounds() {
        blacks.step(ant)
    }
 
    var iRow = 0
 
    while iRow < w {
        var iCol = 0;
        let ln = []
        while iCol < h {
            ln.add(blacks[iCol][iRow] ? "#" : " ")
            iCol += 1
        }
        print(String(values: ln))
        iRow += 1
    }
}
 
run()